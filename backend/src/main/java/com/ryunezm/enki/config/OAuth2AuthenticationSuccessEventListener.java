package com.ryunezm.enki.config;

import com.ryunezm.enki.repositories.UserRepository;
import com.ryunezm.enki.services.OAuth2UserSessionService;
import lombok.AllArgsConstructor;
import org.springframework.context.event.EventListener;
import org.springframework.security.authentication.UsernamePasswordAuthenticationToken;
import org.springframework.security.authentication.event.AuthenticationSuccessEvent;
import org.springframework.security.oauth2.jwt.Jwt;
import org.springframework.stereotype.Component;

import java.time.LocalDateTime;

@AllArgsConstructor
@Component
public class OAuth2AuthenticationSuccessEventListener {
    private final OAuth2UserSessionService oAuth2UserSessionService;
    private final UserRepository userRepository; // To check if it's an internal ADMIN

    @EventListener
    public void handleAuthenticationSuccessEvent(AuthenticationSuccessEvent event) {
        // Check if the authentication was for an OAuth2 user
        if (event.getAuthentication().getPrincipal() instanceof Jwt jwt) {
            String oauth2Id = jwt.getSubject(); // The 'sub' claim is typically the user ID

            // IMPORTANT: Ensure this is not your internal ADMIN user's JWT.
            // A simple check is to see if the 'sub' (oauth2Id) is not the username of your ADMIN.
            // This assumes your ADMIN username is not a valid OAuth2 'sub'.
            // More robust: check the 'iss' (issuer) claim to differentiate.
            // For now, let's assume the ADMIN's JWT comes from the internal auth/login endpoint
            // and contains different claims/issuer, or simply that its username is not a valid OAuth2 ID.

            // The `JwtAuthenticationConverter` path does not directly have the username from your internal users.
            // If the ADMIN's JWT is generated by your internal JwtService, it will have its own 'sub' (username).
            // We need a way to distinguish.
            // The simplest distinction for this listener is that `UsernamePasswordAuthenticationToken` is for ADMIN,
            // and `Jwt` is for OAuth2 users, but the ADMIN's *valid* JWT also becomes a `Jwt` principal.

            // Let's refine the logic:
            // If the Authentication is of type Jwt and it's NOT the result of an internal user
            // logging in via UsernamePasswordAuthenticationToken, then it's an OAuth2 user.
            // How do we know it's not the internal ADMIN's token?
            // The `AuthenticationSuccessEvent` listener catches *all* successful authentications.
            // If the principal is a `Jwt`, it means it passed through the OAuth2 Resource Server.
            // We need to exclude the ADMIN's JWT if it also has "ROLE_ADMIN" and a username match.

            // Best way to differentiate:
            // The `UsernamePasswordAuthenticationToken` flow uses `DaoAuthenticationProvider` and `CustomUserDetailsService`.
            // The OAuth2 flow uses `JwtDecoder` and `JwtAuthenticationConverter`.
            // This event listener will be triggered for both.

            // For internal ADMIN, the initial login will use `UsernamePasswordAuthenticationToken`.
            // After that, the ADMIN will use a JWT, which will also resolve to a `Jwt` principal.
            // To ensure we only record *external* OAuth2 logins:
            // Check if the authentication source is `Jwt` AND the roles are `ROLE_USER`.
            // (Assuming ADMIN has only `ROLE_ADMIN` and OAuth2 users only `ROLE_USER`).
            if (event.getAuthentication().getAuthorities().stream().anyMatch(a -> a.getAuthority().equals("ROLE_USER"))) {
                oAuth2UserSessionService.recordOAuth2UserSession(oauth2Id);
                System.out.println("OAuth2 User logged in: " + oauth2Id + " at " + LocalDateTime.now());
            }

        }
        // For internal ADMIN login (UsernamePasswordAuthenticationToken)
        else if (event.getAuthentication() instanceof UsernamePasswordAuthenticationToken) {
            String username = event.getAuthentication().getName();
            // The lastLogin update for ADMIN is already handled in CustomUserDetailsService's loadUserByUsername
            // when `authenticationManager.authenticate` is called.
            // So, no need to duplicate that here.
            System.out.println("Internal User logged in (or token validated): " + username);
        }
    }
}
